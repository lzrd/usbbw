//! Mermaid diagram generation.

use crate::config::Config;
use crate::model::{BandwidthPool, UsbBus, UsbDevice, UsbTopology, format_bandwidth};

/// Generate a standalone HTML file with embedded Mermaid diagram.
pub fn generate_html(topology: &UsbTopology, config: &Config) -> String {
    let mermaid_code = generate_mermaid_raw(topology, config);

    format!(
        r#"<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>USB Topology</title>
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <style>
    body {{ font-family: system-ui, sans-serif; margin: 2em; }}
    h1 {{ color: #333; }}
    .mermaid {{ background: white; }}
  </style>
</head>
<body>
  <h1>USB Topology</h1>
  <pre class="mermaid">
{}
  </pre>
  <script>mermaid.initialize({{startOnLoad:true, theme:'default', flowchart:{{curve:'basis'}}}});</script>
</body>
</html>
"#,
        mermaid_code
    )
}

/// Generate a Mermaid flowchart diagram of USB topology.
pub fn generate_mermaid(topology: &UsbTopology, config: &Config) -> String {
    format!(
        "```mermaid\n{}\n```\n",
        generate_mermaid_raw(topology, config)
    )
}

/// Generate raw Mermaid code (no markdown wrapper).
fn generate_mermaid_raw(topology: &UsbTopology, config: &Config) -> String {
    let mut output = String::new();

    output.push_str("flowchart TD\n");
    output.push_str("    %% USB Topology Diagram\n");
    output.push_str("    %% Generated by usbbw\n\n");

    // Style definitions - high contrast colors with explicit text styling
    output.push_str("    %% Styles\n");
    output.push_str(
        "    classDef controller fill:#1e40af,stroke:#1e3a8a,color:#ffffff,font-weight:bold\n",
    );
    output.push_str(
        "    classDef usb2bus fill:#166534,stroke:#14532d,color:#ffffff,font-weight:bold\n",
    );
    output.push_str(
        "    classDef usb3bus fill:#c2410c,stroke:#9a3412,color:#ffffff,font-weight:bold\n",
    );
    output
        .push_str("    classDef hub fill:#7c3aed,stroke:#5b21b6,color:#ffffff,font-weight:bold\n");
    output.push_str("    classDef device fill:#fef3c7,stroke:#b45309,color:#000000\n");
    output.push_str(
        "    classDef highbw fill:#dc2626,stroke:#991b1b,color:#ffffff,font-weight:bold\n\n",
    );

    for controller in topology.controllers_sorted() {
        let ctrl_id = sanitize_id(&controller.id.0);
        let ctrl_label = config
            .controller_label(&controller.pci_address)
            .unwrap_or_else(|| format!("Controller<br/>{}", controller.pci_address));

        output.push_str(&format!("    {}[\"{}\"]\n", ctrl_id, ctrl_label));
        output.push_str(&format!("    class {} controller\n", ctrl_id));

        // USB 2.0 bus
        if let Some(bus_num) = controller.usb2_bus
            && let Some(bus) = topology.buses.get(&bus_num)
        {
            add_bus_mermaid(&mut output, bus, topology, config, &ctrl_id, false);
        }

        // USB 3.x bus
        if let Some(bus_num) = controller.usb3_bus
            && let Some(bus) = topology.buses.get(&bus_num)
        {
            add_bus_mermaid(&mut output, bus, topology, config, &ctrl_id, true);
        }

        output.push('\n');
    }

    output
}

/// Generate a markdown document with mermaid diagram and bus summary.
pub fn generate_markdown(topology: &UsbTopology, config: &Config) -> String {
    let mut output = String::new();

    output.push_str("# USB Topology\n\n");

    // Timestamp
    output.push_str(&format!(
        "> Generated by usbbw on {}\n\n",
        chrono_lite_now()
    ));

    // Quick stats
    let total_devices: usize = topology.buses.values().map(|b| b.device_count()).sum();
    let total_power: u32 = topology.buses.values().map(|b| b.total_power_ma()).sum();
    output.push_str(&format!(
        "**Summary:** {} devices across {} buses, {} mA total configured power\n\n",
        total_devices,
        topology.buses.len(),
        total_power
    ));

    // Bus summary table
    output.push_str("## Bus Bandwidth Summary\n\n");
    output.push_str("| Bus | Type | Speed | BW Used | BW Max | Usage | Power | Devices |\n");
    output.push_str("|-----|------|-------|---------|--------|-------|-------|--------|\n");

    for bus in topology.buses_sorted() {
        let pool = BandwidthPool::with_usage(bus.speed, bus.periodic_bandwidth_used_bps());
        let bus_type = if bus.is_superspeed() {
            "USB 3.x"
        } else {
            "USB 2.0"
        };
        let label = config
            .bus_label(bus.bus_num)
            .unwrap_or_else(|| format!("Bus {}", bus.bus_num));
        let power = bus.total_power_ma();

        output.push_str(&format!(
            "| {} | {} | {} | {} | {} | {:.1}% | {} mA | {} |\n",
            label,
            bus_type,
            bus.speed.short_name(),
            pool.format_used(),
            pool.format_max(),
            pool.periodic_usage_percent(),
            power,
            bus.device_count()
        ));
    }

    output.push('\n');

    // High bandwidth devices
    let high_bw_devices: Vec<_> = topology
        .buses
        .values()
        .flat_map(|bus| {
            bus.devices.values().filter_map(|dev| {
                let bw = dev.periodic_bandwidth_bps();
                if bw > 1_000_000 {
                    // > 1 Mbps
                    let label = config
                        .device_label(
                            &dev.path.0,
                            dev.vendor_id,
                            dev.product_id,
                            dev.serial.as_deref(),
                            dev.physical_location.as_ref(),
                        )
                        .unwrap_or_else(|| dev.display_name());
                    Some((label, dev.path.0.clone(), bw))
                } else {
                    None
                }
            })
        })
        .collect();

    if !high_bw_devices.is_empty() {
        output.push_str("## High Bandwidth Devices\n\n");
        output.push_str("Devices reserving >1 Mbps periodic bandwidth:\n\n");
        output.push_str("| Device | Path | Bandwidth |\n");
        output.push_str("|--------|------|----------|\n");

        let mut sorted = high_bw_devices;
        sorted.sort_by(|a, b| b.2.cmp(&a.2));

        for (label, path, bw) in sorted {
            output.push_str(&format!(
                "| {} | `{}` | {} |\n",
                label,
                path,
                format_bandwidth(bw)
            ));
        }
        output.push('\n');
    }

    // Recommendation
    output.push_str("## Bandwidth Availability\n\n");
    output.push_str("**Best buses for new periodic devices:**\n\n");

    let mut buses: Vec<_> = topology.buses_sorted();
    buses.sort_by(|a, b| {
        let a_avail = a.speed.max_periodic_bandwidth_bps() - a.periodic_bandwidth_used_bps();
        let b_avail = b.speed.max_periodic_bandwidth_bps() - b.periodic_bandwidth_used_bps();
        b_avail.cmp(&a_avail)
    });

    for (i, bus) in buses.iter().take(4).enumerate() {
        let pool = BandwidthPool::with_usage(bus.speed, bus.periodic_bandwidth_used_bps());
        let label = config
            .bus_label(bus.bus_num)
            .unwrap_or_else(|| format!("Bus {}", bus.bus_num));
        let bus_type = if bus.is_superspeed() {
            "USB 3.x"
        } else {
            "USB 2.0"
        };

        output.push_str(&format!(
            "{}. **{}** ({}) - {} available\n",
            i + 1,
            label,
            bus_type,
            pool.format_available()
        ));
    }

    output.push('\n');

    // Notes section
    output.push_str("## Notes\n\n");
    output
        .push_str("- **Periodic bandwidth** is reserved by interrupt and isochronous endpoints\n");
    output.push_str("- **Bulk/control transfers** use leftover bandwidth and are not shown\n");
    output.push_str("- **Power values** are configured maximums, not actual consumption\n");
    output.push_str("- USB 2.0 buses share bandwidth with all devices on the bus\n");
    output.push('\n');

    // Mermaid diagram
    output.push_str("## Topology Diagram\n\n");
    output.push_str(&generate_mermaid(topology, config));

    // Legend
    output.push_str("\n### Legend\n\n");
    output.push_str("| Color | Meaning |\n");
    output.push_str("|-------|--------|\n");
    output.push_str("| Dark Blue | USB Controller |\n");
    output.push_str("| Dark Green | USB 2.0 Bus |\n");
    output.push_str("| Dark Orange | USB 3.x Bus |\n");
    output.push_str("| Purple | Hub |\n");
    output.push_str("| Light Yellow | Device |\n");
    output.push_str("| Red | High bandwidth device (>10 Mbps) |\n");

    output
}

/// Simple timestamp without external dependency.
fn chrono_lite_now() -> String {
    use std::process::Command;

    // Use system date command for accurate formatting
    Command::new("date")
        .arg("+%Y-%m-%d %H:%M")
        .output()
        .ok()
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .map(|s| s.trim().to_string())
        .unwrap_or_else(|| "unknown".to_string())
}

fn add_bus_mermaid(
    output: &mut String,
    bus: &UsbBus,
    _topology: &UsbTopology,
    config: &Config,
    parent_id: &str,
    is_superspeed: bool,
) {
    let bus_id = format!("bus{}", bus.bus_num);
    let pool = BandwidthPool::with_usage(bus.speed, bus.periodic_bandwidth_used_bps());

    let label = config
        .bus_label(bus.bus_num)
        .unwrap_or_else(|| format!("Bus {}", bus.bus_num));

    let bus_label = format!(
        "{}<br/>{} ({:.1}%)",
        label,
        bus.speed.short_name(),
        pool.periodic_usage_percent()
    );

    output.push_str(&format!("    {}[\"{}\"]\n", bus_id, bus_label));
    output.push_str(&format!("    {} --> {}\n", parent_id, bus_id));

    let bus_class = if is_superspeed { "usb3bus" } else { "usb2bus" };
    output.push_str(&format!("    class {} {}\n", bus_id, bus_class));

    // Add root-level devices
    for device in bus.devices_tree_order() {
        if device.path.depth() == 0 {
            add_device_mermaid(output, device, bus, config, &bus_id);
        }
    }
}

fn add_device_mermaid(
    output: &mut String,
    device: &UsbDevice,
    bus: &UsbBus,
    config: &Config,
    parent_id: &str,
) {
    // Check if device should be hidden
    if config.should_hide_path(&device.path.0) {
        return;
    }

    // Check vendor filter
    if !config.should_show_vendor(device.vendor_id) {
        return;
    }

    let dev_id = sanitize_id(&device.path.0);

    let label = config
        .device_label(
            &device.path.0,
            device.vendor_id,
            device.product_id,
            device.serial.as_deref(),
            device.physical_location.as_ref(),
        )
        .unwrap_or_else(|| device.display_name());

    let bandwidth = device.periodic_bandwidth_bps();
    let bw_str = if bandwidth > 0 {
        format!("<br/>{}", format_bandwidth(bandwidth))
    } else {
        String::new()
    };

    // Use different shapes for hubs vs devices
    let (shape_open, shape_close) = if device.is_hub {
        ("[[", "]]") // Stadium shape for hubs
    } else {
        ("[", "]") // Rectangle for devices
    };

    output.push_str(&format!(
        "    {}{}\"{}{}\"{}",
        dev_id, shape_open, label, bw_str, shape_close
    ));
    output.push('\n');

    output.push_str(&format!("    {} --> {}\n", parent_id, dev_id));

    // Style based on type and bandwidth
    let class = if device.is_hub {
        "hub"
    } else if bandwidth > 10_000_000 {
        // > 10 Mbps
        "highbw"
    } else {
        "device"
    };
    output.push_str(&format!("    class {} {}\n", dev_id, class));

    // Add children recursively
    for child_path in &device.children {
        if let Some(child) = bus.devices.get(child_path) {
            add_device_mermaid(output, child, bus, config, &dev_id);
        }
    }
}

/// Sanitize string for use as Mermaid node ID.
fn sanitize_id(s: &str) -> String {
    s.replace(['-', '.', ':'], "_")
}
